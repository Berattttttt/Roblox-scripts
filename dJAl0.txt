-- Synapse Decompiler
-- Purchase Here: https://brack4712.xyz/synapse/purchase/

wait(0.2)
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound", Torso)
sick.SoundId = "rbxassetid://142306659"
sick.Looped = true
sick.Pitch = 1
sick.Volume = 3
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
local Weapon = IT("Model")
Weapon.Name = "Adds"
local Effects = IT("Folder", Weapon)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local UNANCHOR = true
local RWINGS = {}
local LWINGS = {}
local EYE, PUPIL
local BLINKLOOP = 0
local FINISHEDINTRO = false
local INTROING = false
local INSTANT = false
local EYES = {}
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id=" .. MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id=" .. TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
local weldBetween = function(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = ACOS(-cosTheta)
		local invSinTheta = 1 / SIN(theta)
		startInterp = SIN((t - 1) * theta) * invSinTheta
		finishInterp = SIN(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function Clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end
function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end
function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end
local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id=" .. ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat
				Swait()
			until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end
function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
function WACKYEFFECT(Table)
	local TYPE = Table.EffectType or "Sphere"
	local SIZE = Table.Size or VT(1, 1, 1)
	local ENDSIZE = Table.Size2 or VT(0, 0, 0)
	local TRANSPARENCY = Table.Transparency or 0
	local ENDTRANSPARENCY = Table.Transparency2 or 1
	local CFRAME = Table.CFrame or Torso.CFrame
	local MOVEDIRECTION = Table.MoveToPos or nil
	local ROTATION1 = Table.RotationX or 0
	local ROTATION2 = Table.RotationY or 0
	local ROTATION3 = Table.RotationZ or 0
	local MATERIAL = Table.Material or "Neon"
	local COLOR = Table.Color or C3(1, 1, 1)
	local TIME = Table.Time or 45
	local SOUNDID = Table.SoundID or nil
	local SOUNDPITCH = Table.SoundPitch or nil
	local SOUNDVOLUME = Table.SoundVolume or nil
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1, 1, 1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh", EFFECT)
			MSH.Scale = VT(SIZE.X, SIZE.X, SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0, 0, 0))
		end
		if MSH ~= nil then
			local MOVESPEED
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude / TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH / TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0, 0, -MSH.Scale.X / 8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				else
					EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat
					Swait()
				until SOUND.Playing == false
				EFFECT:remove()
			end
		elseif PLAYSSOUND == false then
			EFFECT:remove()
		else
			repeat
				Swait()
			until SOUND.Playing == false
			EFFECT:remove()
		end
	end))
end
function CreateDebreeRing(FLOOR, POSITION, SIZE, BLOCKSIZE, SWAIT)
	if FLOOR ~= nil then
		coroutine.resume(coroutine.create(function()
			local PART = CreatePart(3, Effects, "Plastic", 0, 1, "Pearl", "DebreeCenter", VT(0, 0, 0))
			PART.CFrame = CF(POSITION)
			for i = 1, 45 do
				local RingPiece = CreatePart(3, Effects, "Plastic", 0, 0, "Pearl", "DebreePart", BLOCKSIZE)
				RingPiece.Material = FLOOR.Material
				RingPiece.Color = FLOOR.Color
				RingPiece.CFrame = PART.CFrame * ANGLES(RAD(0), RAD(i * 8), RAD(0)) * CF(SIZE * 4, 0, 0) * ANGLES(RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)))
				Debris:AddItem(RingPiece, SWAIT)
			end
			PART:remove()
		end))
	end
end
function CreateFlyingDebree(FLOOR, POSITION, AMOUNT, BLOCKSIZE, SWAIT, STRENGTH)
	if FLOOR ~= nil then
		for i = 1, AMOUNT do
			do
				local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, 0, "Peal", "Debree", BLOCKSIZE, false)
				DEBREE.Material = FLOOR.Material
				DEBREE.Color = FLOOR.Color
				DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)))
				DEBREE.Velocity = VT(MRANDOM(-STRENGTH, STRENGTH), STRENGTH, MRANDOM(-STRENGTH, STRENGTH))
				coroutine.resume(coroutine.create(function()
					Swait(15)
					DEBREE.Parent = workspace
					DEBREE.CanCollide = true
					Debris:AddItem(DEBREE, SWAIT)
				end))
			end
		end
	end
end
function MakeForm(PART, TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh", PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh", PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh", PART)
		MSH.MeshType = "Wedge"
	end
end
function CheckTableForString(Table, String)
	for i, v in pairs(Table) do
		if string.find(string.lower(String), string.lower(v)) then
			return true
		end
	end
	return false
end
function CheckIntangible(Hit)
	local ProjectileNames = {
		"Water",
		"Arrow",
		"Projectile",
		"Effect",
		"Rail",
		"Lightning",
		"Bullet"
	}
	if Hit and Hit.Parent and (not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid") then
		return true
	end
	return false
end
Debris = game:GetService("Debris")
function CastZapRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Ignore = type(Ignore) == "table" and Ignore or {Ignore}
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
	if RayHit and CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = CastZapRay(RayPos + Vec * 0.01, Vec, Length - (StartPos - RayPos).magnitude, Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end
function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos, EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end
function turnto(position)
	RootPart.CFrame = CFrame.new(RootPart.CFrame.p, VT(position.X, RootPart.Position.Y, position.Z)) * CFrame.new(0, 0, 0)
end
BaseLightning = IT("Part")
BaseLightning.Anchored = true
BaseLightning.CanCollide = false
BaseLightning.Material = "Neon"
local LightningBolts = {}
function Zap(Table)
	local StartPos, TargetPos, Character, Color = Table.StartPosition, Table.TargetPosition, Table.Character, Table.Color
	local Duration = Table.Duration or 2
	local Offset = Table.Offset or 2
	local Individualize = Table.Individualize or false
	local MaxRange = Table.MaxRange or 200
	local SegmentLength = Table.SegmentLength or 5
	local Transparency = Table.Transparency or 0
	local Ignore = Table.Ignore or {}
	local SIZE = Table.SIZE or 0.3
	if not (StartPos and TargetPos) or not Character then
		return
	end
	local LightningModel = IT("Folder", Effects)
	LightningModel.Name = "ZAPP"
	for i, v in pairs({Character, LightningModel}) do
		table.insert(Ignore, v)
	end
	local LastPos = StartPos
	local Direction = CFrame.new(StartPos, TargetPos).lookVector
	local RayHit, RayPos, RayNormal = CastZapRay(StartPos, Direction, MaxRange, Ignore, false)
	local RayLength = (StartPos - RayPos).Magnitude
	local Struck = false
	local TotalSegments = math.ceil(RayLength / SegmentLength)
	Direction = CFrame.new(StartPos, RayPos).lookVector
	local LightningBolt = IT("Model", Effects)
	LightningBolt.Name = "Lightning"
	LastBolt = LightningBolt
	Debris:AddItem(LightningBolt, Duration)
	LightningBolt.Parent = LightningModel
	for i = 1, TotalSegments do
		if not Struck then
			local Entropy = Vector3.new(math.random() * Offset * 2.5 - Offset, math.random() * Offset * 2.5 - Offset, math.random() * Offset * 2.5 - Offset)
			local NewPos = StartPos + Direction * (RayLength * (i / TotalSegments)) + Entropy
			local SegmentVec = NewPos - LastPos
			local RayHit, RayPos, RayNormal = CastZapRay(LastPos, SegmentVec.Unit, SegmentVec.Magnitude, {Character, LightningModel}, false)
			local RayVec = LastPos - RayPos
			local LightningPart = BaseLightning:Clone()
			LightningPart.BrickColor = BrickColor.new(Color)
			LightningPart.Transparency = Transparency
			LightningPart.Size = Vector3.new(SIZE, SIZE, RayVec.Magnitude)
			LightningPart.CFrame = CFrame.new(LastPos, RayPos) * CFrame.new(0, 0, -(RayVec.Magnitude / 2))
			local CylinderMesh = IT("CylinderMesh", LightningPart)
			local OrigCF = LightningPart.CFrame
			LightningPart.Size = Vector3.new(LightningPart.Size.X, LightningPart.Size.Z, LightningPart.Size.Y)
			LightningPart.CFrame = OrigCF * CFrame.Angles(math.pi / 2, 0, 0)
			LightningPart.Parent = LightningBolt
			LastPos = NewPos
		end
	end
	return {
		RayHit = RayHit,
		RayPos = RayPos,
		RayNormal = RayNormal,
		LightningModel = LightningModel
	}
end
function Blink()
	coroutine.resume(coroutine.create(function()
		if EYE ~= nil and PUPIL ~= nil then
			for i = 1, 5 do
				Swait()
				EYE.Mesh.Scale = EYE.Mesh.Scale - VT(0, 0.2, 0)
				PUPIL.Mesh.Scale = PUPIL.Mesh.Scale - VT(0, 0.2, 0)
			end
			for i = 1, 7 do
				Swait()
				EYE.Mesh.Scale = EYE.Mesh.Scale + VT(0, 0.2, 0)
				PUPIL.Mesh.Scale = PUPIL.Mesh.Scale + VT(0, 0.2, 0)
			end
			EYE.Mesh.Scale = VT(1, 1, 1)
			PUPIL.Mesh.Scale = VT(1, 1, 1)
		end
	end))
end
local BODY = {}
function Face()
	local FACE = CreatePart(3, Weapon, "Fabric", 0, 0, "Dark stone grey", "Face", VT(1.01, 0.725, 1.01), false)
	FACE.Color = C3(0, 0, 0)
	Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0, 0.225, 0), CF(0, 0, 0))
	EYE = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Eyeball", VT(0.15, 0.3, 0.15), false)
	MakeForm(EYE, "Ball")
	CreateWeldOrSnapOrMotor("Weld", Head, Head, EYE, CF(0.15, 0.26, -0.55), CF(0, 0, 0))
	PUPIL = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Eyeball", VT(0.05, 0.2, 0.05), false)
	PUPIL.Color = C3(0, 0, 0)
	MakeForm(PUPIL, "Ball")
	CreateWeldOrSnapOrMotor("Weld", Head, Head, PUPIL, CF(0.15, 0.26, -0.6), CF(0, 0, 0))
	local LASTPART = Head
	for i = 1, 30 do
		local MATH = 1 - i / 40
		if LASTPART == Head then
			local Horn = CreatePart(3, Weapon, "SmoothPlastic", 0, 0, "Dirt brown", "Horn", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.5, 0.35, -0.15) * ANGLES(RAD(-15), RAD(15), RAD(-15)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i * 2 - 2) / 255, (i * 2 - 2) / 255, (i * 2 - 2) / 255)
		else
			local Horn = CreatePart(3, Weapon, "SmoothPlastic", 0, 0, "Dirt brown", "Horn", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y / 1.8, 0) * ANGLES(RAD(17), RAD(3), RAD(0)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i * 2 - 2) / 255, (i * 2 - 2) / 255, (i * 2 - 2) / 255)
		end
	end
	local LASTPART = Head
	for i = 1, 30 do
		local MATH = 1 - i / 40
		if LASTPART == Head then
			local Horn = CreatePart(3, Weapon, "SmoothPlastic", 0, 0, "Dirt brown", "Horn", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(-0.5, 0.35, -0.15) * ANGLES(RAD(-15), RAD(-15), RAD(15)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i * 2 - 2) / 255, (i * 2 - 2) / 255, (i * 2 - 2) / 255)
		else
			local Horn = CreatePart(3, Weapon, "SmoothPlastic", 0, 0, "Dirt brown", "Horn", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
			CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y / 1.8, 0) * ANGLES(RAD(17), RAD(-3), RAD(0)), CF(0, 0, 0))
			LASTPART = Horn
			Horn.Color = C3((i * 2 - 2) / 255, (i * 2 - 2) / 255, (i * 2 - 2) / 255)
		end
	end
	BODY = {}
	for _, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") then
			table.insert(BODY, {
				c,
				c.Parent,
				c.Material,
				c.Color
			})
		elseif c:IsA("JointInstance") then
			table.insert(BODY, {
				c,
				c.Parent,
				nil,
				nil
			})
		end
	end
end
function RightWing()
	for i = 1, 2 do
		local PART
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.5, 0.5, 0.5), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", Torso, Torso, Wing, CF(0.8, 0.75 - 0.25 * i, 1) * ANGLES(RAD(0), RAD(-15 * i), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-30 * i)), CF(0, 0, 0))
		table.insert(RWINGS, WingWeld)
		PART = Wing
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "LargeWing", VT(1, 1.7, 1), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.5, 0) * ANGLES(RAD(15), RAD(25), RAD(0)), CF(0, -0.8, 0))
		PART = Wing
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.5, 0.5, 0.5), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.9, 0) * ANGLES(RAD(-8), RAD(0), RAD(0)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Marble", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.2, 0.51), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(15)), CF(0, 0, 0))
		PART = Wing
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.2, 0.5, 0.2), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.65, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.8, 0.15, 0.15), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0.7, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Cobblestone", 0, 0, "Dark orange", "WingPart", VT(0.25, 0.2, 0.25), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, 0, 0), CF(0, 0, 0))
		PART = Wing
		table.insert(RWINGS, WingWeld)
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.4, 0.5, 0.4), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.65, 0) * ANGLES(RAD(-5), RAD(0), RAD(15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Cobblestone", 0, 0, "Dark indigo", "WingPart", VT(0.45, 0.2, 0.45), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, 0, 0), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.15, 0.15), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0.8, 0.1, 0) * ANGLES(RAD(0), RAD(0), RAD(15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.1, 0.1), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(1, 0.1, 0) * ANGLES(RAD(0), RAD(0), RAD(25)), CF(-0.8, 0, 0))
		PART = Wing
		table.insert(RWINGS, WingWeld)
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.2, 0.5, 0.2), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(-0.18, 0.25, 0) * ANGLES(RAD(0), RAD(0), RAD(15)), CF(0, 0, 0))
		PART = Wing
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.5, 0.5, 0.5), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.55, 0) * ANGLES(RAD(-15), RAD(15), RAD(15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.3, 0.3), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0.8, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark orange", "WingPart", VT(1, 0.2, 0.2), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(1, 0.1, 0) * ANGLES(RAD(0), RAD(0), RAD(25)), CF(-0.8, 0.15, 0))
		PART = Wing
		table.insert(RWINGS, WingWeld)
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Maroon", "WingPart", VT(1, 1, 1), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0.4, 0.95, 0) * ANGLES(RAD(-5), RAD(0), RAD(15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark orange", "WingPart", VT(0.3, 0.3, 0.3), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, -0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.7, 0.7, 0.7), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, 0, -0.2) * ANGLES(RAD(0), RAD(0), RAD(25)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Neon", 0, 0, "Burgundy", "WingPart", VT(0.45, 0.45, 0.45), false)
		table.insert(EYES, Wing1)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, 0, -0.35) * ANGLES(RAD(0), RAD(0), RAD(-35)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.1, 0.1), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0.8, -0.2, 0) * ANGLES(RAD(0), RAD(0), RAD(25)), CF(0, 0, 0))
		PART = Wing
		table.insert(RWINGS, WingWeld)
	end
	BODY = {}
	for _, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") then
			table.insert(BODY, {
				c,
				c.Parent,
				c.Material,
				c.Color
			})
		elseif c:IsA("JointInstance") then
			table.insert(BODY, {
				c,
				c.Parent,
				nil,
				nil
			})
		end
	end
end
function LeftWing()
	for i = 1, 2 do
		local PART
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.5, 0.5, 0.5), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", Torso, Torso, Wing, CF(-0.8, 0.75 - 0.25 * i, 1) * ANGLES(RAD(0), RAD(15 * i), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(30 * i)), CF(0, 0, 0))
		table.insert(LWINGS, WingWeld)
		PART = Wing
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "LargeWing", VT(1, 1.7, 1), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.5, 0) * ANGLES(RAD(15), RAD(-25), RAD(0)), CF(0, -0.8, 0))
		PART = Wing
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.5, 0.5, 0.5), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.9, 0) * ANGLES(RAD(-8), RAD(0), RAD(0)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Marble", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.2, 0.51), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)), CF(0, 0, 0))
		PART = Wing
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.2, 0.5, 0.2), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.65, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.8, 0.15, 0.15), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(-0.7, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Cobblestone", 0, 0, "Dark orange", "WingPart", VT(0.25, 0.2, 0.25), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, 0, 0), CF(0, 0, 0))
		PART = Wing
		table.insert(LWINGS, WingWeld)
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.4, 0.5, 0.4), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.65, 0) * ANGLES(RAD(-5), RAD(0), RAD(-15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Cobblestone", 0, 0, "Dark indigo", "WingPart", VT(0.45, 0.2, 0.45), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, 0, 0), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.15, 0.15), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(-0.8, 0.1, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.1, 0.1), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(-1, 0.1, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)), CF(0.8, 0, 0))
		PART = Wing
		table.insert(LWINGS, WingWeld)
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.2, 0.5, 0.2), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0.18, 0.25, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)), CF(0, 0, 0))
		PART = Wing
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.5, 0.5, 0.5), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(0, 0.55, 0) * ANGLES(RAD(-15), RAD(-15), RAD(-15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.3, 0.3), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(-0.8, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark orange", "WingPart", VT(1, 0.2, 0.2), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(-1, 0.1, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)), CF(0.8, 0.15, 0))
		PART = Wing
		table.insert(LWINGS, WingWeld)
		local Wing = CreatePart(3, Weapon, "Granite", 0, 0, "Maroon", "WingPart", VT(1, 1, 1), false)
		local WingWeld = CreateWeldOrSnapOrMotor("Weld", PART, PART, Wing, CF(-0.4, 0.95, 0) * ANGLES(RAD(-5), RAD(0), RAD(-15)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark orange", "WingPart", VT(0.3, 0.3, 0.3), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, -0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(0.7, 0.7, 0.7), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, 0, -0.2) * ANGLES(RAD(0), RAD(0), RAD(-25)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Neon", 0, 0, "Burgundy", "WingPart", VT(0.45, 0.45, 0.45), false)
		table.insert(EYES, Wing1)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(0, 0, -0.35) * ANGLES(RAD(0), RAD(0), RAD(35)), CF(0, 0, 0))
		local Wing1 = CreatePart(3, Weapon, "Granite", 0, 0, "Dark stone grey", "WingPart", VT(1, 0.1, 0.1), false)
		CreateWeldOrSnapOrMotor("Weld", Wing, Wing, Wing1, CF(-0.8, -0.2, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)), CF(0, 0, 0))
		PART = Wing
		table.insert(LWINGS, WingWeld)
	end
	BODY = {}
	for _, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") then
			table.insert(BODY, {
				c,
				c.Parent,
				c.Material,
				c.Color
			})
		elseif c:IsA("JointInstance") then
			table.insert(BODY, {
				c,
				c.Parent,
				nil,
				nil
			})
		end
	end
end
for _, c in pairs(Weapon:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") then
		table.insert(BODY, {
			c,
			c.Parent,
			c.Material,
			c.Color
		})
	elseif c:IsA("JointInstance") then
		table.insert(BODY, {
			c,
			c.Parent,
			nil,
			nil
		})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		do
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			PART.AncestryChanged:Connect(function()
				if PART.ClassName == "Part" then
					PART.Material = MATERIAL
					PART.Color = COLOR
				end
				PART.Parent = PARENT
			end)
		end
	end
end
function refit()
	Weapon.Parent = Character
	Character.Parent = workspace
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			if PART.Parent ~= PARENT then
				Humanoid:remove()
				if PART.ClassName == "Part" then
					PART.Material = MATERIAL
					PART.Color = COLOR
				end
				PART.Parent = PARENT
				Humanoid = IT("Humanoid", Character)
			end
		end
	end
end
local SKILLTEXTCOLOR = C3(0, 0, 0)
local SKILLFONT = "SciFi"
local SKILLTEXTSIZE = 7
Weapon.Parent = Character
Humanoid.Died:connect(function()
	refit()
end)
local SKILL1FRAME = CreateFrame(WEAPONGUI, 0.75, 2, UD2(0.23, 0, 0.8, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 0.75, 2, UD2(0.5, 0, 0.8, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 0.75, 2, UD2(0.365, 0, 0.9, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Neck Snap", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 1, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Imperfect Command", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 1, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Fire At Will", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 1, "Text 3")
function StatLabel(CFRAME, TEXT, COLOR)
	local STATPART = CreatePart(3, Effects, "SmoothPlastic", 0, 1, "Really black", "Effect", VT())
	STATPART.CFrame = CF(CFRAME.p, CFRAME.p + VT(MRANDOM(-5, 5), MRANDOM(0, 5), MRANDOM(-5, 5)))
	local BODYGYRO = IT("BodyGyro", STATPART)
	game:GetService("Debris"):AddItem(STATPART, 5)
	local BILLBOARDGUI = Instance.new("BillboardGui", STATPART)
	BILLBOARDGUI.Adornee = STATPART
	BILLBOARDGUI.Size = UD2(2.5, 0, 2.5, 0)
	BILLBOARDGUI.StudsOffset = VT(-2, 2, 0)
	BILLBOARDGUI.AlwaysOnTop = false
	local TEXTLABEL = Instance.new("TextLabel", BILLBOARDGUI)
	TEXTLABEL.BackgroundTransparency = 1
	TEXTLABEL.Size = UD2(2.5, 0, 2.5, 0)
	TEXTLABEL.Text = TEXT
	TEXTLABEL.Font = SKILLFONT
	TEXTLABEL.FontSize = "Size42"
	TEXTLABEL.TextColor3 = COLOR
	TEXTLABEL.TextStrokeTransparency = 0
	TEXTLABEL.TextScaled = true
	TEXTLABEL.TextWrapped = true
	coroutine.resume(coroutine.create(function(THEPART, THEBODYPOSITION, THETEXTLABEL)
		for i = 1, 50 do
			Swait()
			STATPART.CFrame = STATPART.CFrame * CF(0, 0, -0.2)
			TEXTLABEL.TextTransparency = TEXTLABEL.TextTransparency + 0.02
			TEXTLABEL.TextStrokeTransparency = TEXTLABEL.TextTransparency
		end
		THEPART.Parent = nil
	end), STATPART, TEXTLABEL)
end
function Ragdoll(Character2, CharTorso, Headless, Velocity)
	local svch = Character2
	Character2:BreakJoints()
	local hum = Character2:findFirstChild("Humanoid")
	local q = Character2:GetChildren()
	local CLONE = IT("Model", Effects)
	for i = 1, #q do
		if q[i].ClassName == "Accessory" and Headless == true then
			q[i]:remove()
		elseif q[i].ClassName ~= "Humanoid" and q[i].ClassName ~= "LocalScript" and q[i].ClassName ~= "Script" and q[i].ClassName ~= "Gear" then
			q[i].Parent = CLONE
		elseif q[i].ClassName ~= "Humanoid" then
			q[i]:remove()
		end
	end
	local chrclone = CLONE
	local ch = chrclone:GetChildren()
	local i
	for i = 1, #ch do
		if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" or ch[i].ClassName == "Script" then
			ch[i]:remove()
		end
	end
	local function Scan(ch)
		local e
		for e = 1, #ch do
			Scan(ch[e]:GetChildren())
			if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
				ch[e]:remove()
			end
		end
	end
	Character2:remove()
	local NEWHUM = IT("Humanoid")
	NEWHUM.Name = "Corpse"
	NEWHUM.Health = 0
	NEWHUM.MaxHealth = 0
	NEWHUM.PlatformStand = true
	NEWHUM.Parent = CLONE
	NEWHUM.DisplayDistanceType = "None"
	Scan(chrclone:GetChildren())
	local ch = Character2:GetChildren()
	local i
	for i = 1, #ch do
		if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
			ch[i]:remove()
		end
	end
	local ch = Character2:GetChildren()
	local i
	for i = 1, #ch do
		if ch[i].ClassName == "Part" or ch[i].ClassName == "Hat" or ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
			ch[i]:remove()
		end
	end
	Character2 = chrclone
	local Torso2 = Character2.Torso
	local movevector = Vector3.new()
	if Torso2 then
		movevector = CFrame.new(CharTorso.Position, Torso2.Position).lookVector
		local Head = Character2:FindFirstChild("Head")
		if Head then
			local Neck = Instance.new("Weld")
			Neck.Name = "Neck"
			Neck.Part0 = Torso2
			Neck.Part1 = Head
			Neck.C0 = CFrame.new(0, 1.5, 0)
			Neck.C1 = CFrame.new()
			Neck.Parent = Torso2
			if Headless == true then
				Head.Transparency = 1
				Head:ClearAllChildren()
			end
		end
		local Limb = Character2:FindFirstChild("Right Arm")
		if Limb then
			Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "RightShoulder"
			Joint.Part0 = Torso2
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
			Joint.C1 = CFrame.new(0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
			Joint.Parent = Torso2
			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = Character2
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb
		end
		local Limb = Character2:FindFirstChild("Left Arm")
		if Limb then
			Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "LeftShoulder"
			Joint.Part0 = Torso2
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(-1.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			Joint.C1 = CFrame.new(0, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			Joint.Parent = Torso2
			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = Character2
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb
		end
		local Limb = Character2:FindFirstChild("Right Leg")
		if Limb then
			Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "RightHip"
			Joint.Part0 = Torso2
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
			Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
			Joint.Parent = Torso2
			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = Character2
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb
		end
		local Limb = Character2:FindFirstChild("Left Leg")
		if Limb then
			Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "LeftHip"
			Joint.Part0 = Torso2
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(-0.5, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			Joint.C1 = CFrame.new(0, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			Joint.Parent = Torso2
			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = Character2
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb
		end
		local Bar = Instance.new("Part")
		Bar.TopSurface = 0
		Bar.BottomSurface = 0
		Bar.formFactor = "Symmetric"
		Bar.Size = Vector3.new(1, 1, 1)
		Bar.Transparency = 1
		Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
		Bar.Parent = Character2
		local Weld = Instance.new("Weld")
		Weld.Part0 = Torso2
		Weld.Part1 = Bar
		Weld.C0 = CFrame.new(0, 0.5, 0)
		Weld.Parent = Torso2
	end
	Character2.Parent = Weapon
	if movevector ~= Vector3.new() then
		for i = 1, 10 do
			Torso2.Velocity = movevector * Velocity
		end
	end
	Character2.Name = "Corpse"
	return Character2, Torso2
end
function PuddleOfBlood(Position, MaxDrop, Model, MaxSize)
	local HITFLOOR, HITPOS, NORMAL = Raycast(Position, CF(Position, Position + VT(0, -1, 0)).lookVector, MaxDrop, Model)
	if HITFLOOR ~= nil and HITFLOOR.Parent ~= Weapon and HITFLOOR.Parent ~= Character then
		if HITFLOOR.Name == "BloodPuddle" then
			local DIST = (Position - HITFLOOR.Position).Magnitude
			if HITFLOOR.Size.Z <= 5 and MaxSize > HITFLOOR.Size.Z or HITFLOOR.Size.Z > 5 and MaxSize > HITFLOOR.Size.Z and DIST < HITFLOOR.Size.Z / 3 then
				HITFLOOR.Size = HITFLOOR.Size + VT(0.1, 0, 0.1)
			end
		elseif HITFLOOR.Anchored == true then
			do
				local BLOOD = CreatePart(3, Effects, "Glass", 0, 0, "Maroon", "BloodPuddle", VT(2, 0, 2))
				BLOOD.CFrame = CF(HITPOS, HITPOS + NORMAL) * ANGLES(RAD(90), RAD(0), RAD(0))
				MakeForm(BLOOD, "Cyl")
				coroutine.resume(coroutine.create(function()
					Swait(75)
					while true do
						Swait()
						BLOOD.Size = BLOOD.Size - VT(0.02, 0, 0.02)
						if BLOOD.Size.Z < 0.051 then
							BLOOD:remove()
							break
						end
					end
				end))
			end
		end
	end
end
function SprayBlood(POSITION, DIRECTION, BloodSize)
	local BLOOD = CreatePart(3, Effects, "Glass", 0, 0, "Maroon", "BloodPuddle", VT(1, 1, 1), false)
	BLOOD.CFrame = CF(POSITION)
	MakeForm(BLOOD, "Ball")
	local bv = Instance.new("BodyVelocity", BLOOD)
	bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
	bv.velocity = CF(POSITION, DIRECTION + VT(MRANDOM(-3, 3) / 30, MRANDOM(-3, 3) / 30, MRANDOM(-3, 3) / 30)).lookVector * 25
	bv.Name = "MOVE"
	Debris:AddItem(bv, 0.05)
	coroutine.resume(coroutine.create(function()
		local HASTOUCHEDGROUND = false
		local HIT = BLOOD.Touched:Connect(function(hit)
			if hit.Anchored == true then
				HASTOUCHEDGROUND = true
				PuddleOfBlood(BLOOD.Position + VT(0, 1, 0), 2, BLOOD, BloodSize)
			end
		end)
		wait(5)
		if HASTOUCHEDGROUND == false then
			BLOOD:remove()
		end
	end))
end
function ApplyDamage(Humanoid, Damage, TorsoPart)
	local defence = Instance.new("BoolValue", Humanoid.Parent)
	defence.Name = "HitBy" .. Player.Name
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(1, 100)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
				Damage = 0.1
			end
		end
		Humanoid.Health = Humanoid.Health - Damage
		StatLabel(TorsoPart.CFrame * CF(0, 0 + (TorsoPart.Size.z - 1), 0), Damage, C3(0, 0, 0))
	end
end
function ApplyAoE(POSITION, RANGE, MINDMG, MAXDMG, FLING, INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
					if INSTAKILL == true then
						Petrify(CHILD)
					else
						local DMG = MRANDOM(MINDMG, MAXDMG)
						ApplyDamage(HUM, DMG, TORSO)
					end
					if FLING > 0 then
						for _, c in pairs(CHILD:GetChildren()) do
							if c:IsA("BasePart") then
								local bv = Instance.new("BodyVelocity")
								bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
								bv.velocity = CF(POSITION, TORSO.Position).lookVector * FLING
								bv.Parent = c
								Debris:AddItem(bv, 0.05)
							end
						end
					end
				end
			end
		end
	end
end
function Petrify(Foe)
	local STONEMODEL = IT("Model", Effects)
	local CHILDREN = Foe:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD:IsA("BasePart") and CHILD.Parent.ClassName ~= "Folder" then
			CHILD.Parent = STONEMODEL
			CHILD.Material = "Slate"
			CHILD.Color = C3(0.5, 0.5, 0.5)
			if CHILD:FindFirstChildOfClass("SpecialMesh") then
				local mesh = CHILD:FindFirstChildOfClass("SpecialMesh")
				mesh.TextureId = ""
			end
			if CHILD:FindFirstChildOfClass("Decal") then
				local mesh = CHILD:FindFirstChildOfClass("Decal")
				mesh:remove()
			end
			if CHILD.ClassName == "MeshPart" then
				CHILD.TextureID = ""
			end
			if CHILD.ClassName == "UnionOperation" then
				CHILD.UsePartColor = true
			end
			CHILD.CanCollide = true
		end
	end
	Debris:AddItem(STONEMODEL, 5)
end
function Intro()
	coroutine.resume(coroutine.create(function()
		INTROING = true
		Rooted = true
		sick:Play()
		FINISHEDINTRO = true
		Head.Transparency = 1
		Torso.Transparency = 1
		LeftArm.Transparency = 1
		RightArm.Transparency = 1
		LeftLeg.Transparency = 1
		RightLeg.Transparency = 1
		repeat
			Swait()
		until sick.TimePosition > 3.2
		for i = 1, 5 do
			WACKYEFFECT({
				EffectType = "Sphere",
				Size = VT(3, 3, 3),
				Size2 = VT(0, 5, 0),
				Transparency = 0.5,
				Transparency2 = 1,
				CFrame = Torso.CFrame,
				MoveToPos = Torso.CFrame * CF(15, -5 + i * 3, 1).p,
				RotationX = MRANDOM(-5, 5),
				RotationY = MRANDOM(-5, 5),
				RotationZ = MRANDOM(-5, 5),
				Material = "Neon",
				Color = C3(1, 0, 0),
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		RightWing()
		repeat
			Swait()
		until sick.TimePosition > 6.2
		for i = 1, 5 do
			WACKYEFFECT({
				EffectType = "Sphere",
				Size = VT(3, 3, 3),
				Size2 = VT(0, 5, 0),
				Transparency = 0.5,
				Transparency2 = 1,
				CFrame = Torso.CFrame,
				MoveToPos = Torso.CFrame * CF(-15, -5 + i * 3, 1).p,
				RotationX = MRANDOM(-5, 5),
				RotationY = MRANDOM(-5, 5),
				RotationZ = MRANDOM(-5, 5),
				Material = "Neon",
				Color = C3(1, 0, 0),
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		LeftWing()
		repeat
			Swait()
		until sick.TimePosition > 16
		for i = 1, 6 do
			WACKYEFFECT({
				EffectType = "Sphere",
				Size = VT(1.5, 1.5, 1.5),
				Size2 = VT(4, 4, 4) * i,
				Transparency = 0,
				Transparency2 = 1,
				CFrame = Head.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = C3(1, 0, 0),
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		Head.Transparency = 0
		Face()
		wait(1)
		for i = 1, 100 do
			Swait()
			Torso.Transparency = 1 - i / 100
			LeftArm.Transparency = 1 - i / 100
			RightArm.Transparency = 1 - i / 100
			LeftLeg.Transparency = 1 - i / 100
			RightLeg.Transparency = 1 - i / 100
		end
		FINISHEDINTRO = true
		Rooted = false
	end))
end
function Neck_Snap()
	ATTACK = true
	Rooted = false
	local TARGET, HUM, WLD
	local HIT = RightArm.Touched:Connect(function(hit)
		if hit.Parent ~= nil and hit.Parent:FindFirstChildOfClass("Humanoid") then
			local H = hit.Parent:FindFirstChildOfClass("Humanoid")
			if H.Health > 0 then
				local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
				if TORSO then
					HUM = H
					TARGET = TORSO
					H.PlatformStand = true
					CreateSound("260411131", TORSO, 10, 1)
					WLD = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, TORSO, CF(0, -1, -0.25) * ANGLES(RAD(-90), RAD(0), RAD(0)), CF(0, 0, 0))
				end
			end
		end
	end)
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		if TARGET ~= nil then
			break
		end
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.45, -0.3) * ANGLES(RAD(90), RAD(0), RAD(-12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		if ANIM == "Idle" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		elseif ANIM == "Walk" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ANIM == "Jump" or ANIM == "Fall" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
		end
	end
	HIT:disconnect()
	if TARGET ~= nil then
		if TARGET.Name == "Torso" then
			for i = 0, 2, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(65), RAD(25), RAD(-45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(120), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				if ANIM == "Idle" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				elseif ANIM == "Walk" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
				elseif ANIM == "Jump" or ANIM == "Fall" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
				end
			end
			WLD:remove()
			local HEAD = TARGET.Parent:FindFirstChild("Head")
			if HEAD then
				UNANCHOR = false
				RootPart.Anchored = true
				local HD = HEAD:Clone()
				HD.Name = "FakeHead"
				for i = 1, 7 do
					SprayBlood(TARGET.CFrame * CF(0, TARGET.Size.Y / 2, 0).p, TARGET.CFrame * CF(MRANDOM(25, 55), MRANDOM(-25, 25), MRANDOM(25, 55)).p, 15)
				end
				local RAGDOLL, RAGTORSO = Ragdoll(TARGET.Parent, Torso, true, 0)
				local RAGWELD = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, RAGTORSO, CF(0, -1, -0.25) * ANGLES(RAD(-90), RAD(0), RAD(0)), CF(0, 0, 0))
				HD.Parent = RAGDOLL
				CreateSound("264486467", RAGTORSO, 10, 1)
				local HEADWELD = CreateWeldOrSnapOrMotor("Weld", LeftArm, LeftArm, HD, CF(0, -1, -0.25) * ANGLES(RAD(-90), RAD(0), RAD(0)), CF(0, 0, 0))
				for i = 0, 2, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(150), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					if ANIM == "Idle" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					elseif ANIM == "Walk" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					elseif ANIM == "Jump" or ANIM == "Fall" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
					end
				end
				HEADWELD:remove()
				for i = 0, 0.5, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(-65)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					if ANIM == "Idle" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					elseif ANIM == "Walk" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					elseif ANIM == "Jump" or ANIM == "Fall" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
					end
				end
				CreateSound("907333406", Torso, 10, 1)
				for i = 0, 0.25, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					if ANIM == "Idle" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					elseif ANIM == "Walk" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					elseif ANIM == "Jump" or ANIM == "Fall" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
					end
				end
				RAGWELD:remove()
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
				bv.velocity = CF(Torso.Position, RAGTORSO.Position).lookVector * 75
				bv.Parent = RAGTORSO
				Debris:AddItem(bv, 0.05)
				Debris:AddItem(RAGDOLL, 5)
				for i = 0, 0.15, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					if ANIM == "Idle" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					elseif ANIM == "Walk" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					elseif ANIM == "Jump" or ANIM == "Fall" then
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
					end
				end
				UNANCHOR = true
				RootPart.Anchored = false
			end
		else
			UNANCHOR = false
			RootPart.Anchored = true
			for i = 0, 0.5, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(-65)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				if ANIM == "Idle" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				elseif ANIM == "Walk" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
				elseif ANIM == "Jump" or ANIM == "Fall" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
				end
			end
			for i = 0, 0.25, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				if ANIM == "Idle" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				elseif ANIM == "Walk" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
				elseif ANIM == "Jump" or ANIM == "Fall" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
				end
			end
			WLD:remove()
			TARGET.Parent:BreakJoints()
			for _, c in pairs(TARGET.Parent:GetChildren()) do
				if c:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
					bv.velocity = CF(Torso.Position, c.Position).lookVector * 75
					bv.Parent = c
					Debris:AddItem(bv, 0.05)
				end
			end
			for i = 0, 0.15, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				if ANIM == "Idle" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				elseif ANIM == "Walk" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
				elseif ANIM == "Jump" or ANIM == "Fall" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
				end
			end
			UNANCHOR = true
			RootPart.Anchored = false
		end
	end
	ATTACK = false
	Rooted = false
end
function Imperfect_Command()
	ATTACK = true
	Rooted = true
	if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
		local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
		local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
		if TORSO then
			local GYRO = IT("BodyGyro", RootPart)
			GYRO.D = 750
			GYRO.P = 2000
			GYRO.MaxTorque = VT(0, 40000, 0)
			CreateSound("907330103", Torso, 10, 1)
			for i = 0, 1.6, 0.1 / Animation_Speed do
				Swait()
				WACKYEFFECT({
					Time = 5,
					EffectType = "Round Slash",
					Size = VT(0, 0, 0),
					Size2 = VT(0.01, 0, 0.01),
					Transparency = 0.5,
					Transparency2 = 1,
					CFrame = CF(EYE.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
					MoveToPos = nil,
					RotationX = MRANDOM(-50, 50) / 10,
					RotationY = MRANDOM(-50, 50) / 10,
					RotationZ = MRANDOM(-50, 50) / 10,
					Material = "Neon",
					Color = C3(1, 0, 0),
					SoundID = nil,
					SoundPitch = nil,
					SoundVolume = nil
				})
				GYRO.cframe = CF(RootPart.Position, TORSO.Position)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.025 * COS(SINE / 22), -1) * ANGLES(RAD(120), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-45)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0 + 0.025 * COS(SINE / 22), -1) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(90 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				if ANIM == "Idle" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				elseif ANIM == "Walk" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
				elseif ANIM == "Jump" or ANIM == "Fall" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
				end
			end
			GYRO:remove()
			for i = 1, 15 do
				WACKYEFFECT({
					Time = MRANDOM(15, 85),
					EffectType = "Round Slash",
					Size = VT(0, 0, 0),
					Size2 = VT(0.3, 0, 0.3),
					Transparency = 0.5,
					Transparency2 = 1,
					CFrame = CF(TORSO.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
					MoveToPos = nil,
					RotationX = MRANDOM(-50, 50) / 10,
					RotationY = MRANDOM(-50, 50) / 10,
					RotationZ = MRANDOM(-50, 50) / 10,
					Material = "Neon",
					Color = C3(1, 0, 0),
					SoundID = nil,
					SoundPitch = nil,
					SoundVolume = nil
				})
			end
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
			bv.velocity = CF(Torso.Position, TORSO.Position).lookVector * 5
			bv.Parent = TORSO
			Debris:AddItem(bv, 0.05)
			CreateSound("1222405264", TORSO, 10, 1)
			Petrify(HUM.Parent)
			for i = 0, 0.5, 0.1 / Animation_Speed do
				Swait()
				WACKYEFFECT({
					Time = 5,
					EffectType = "Round Slash",
					Size = VT(0, 0, 0),
					Size2 = VT(0.01, 0, 0.01),
					Transparency = 0.5,
					Transparency2 = 1,
					CFrame = CF(EYE.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
					MoveToPos = nil,
					RotationX = MRANDOM(-50, 50) / 10,
					RotationY = MRANDOM(-50, 50) / 10,
					RotationZ = MRANDOM(-50, 50) / 10,
					Material = "Neon",
					Color = C3(1, 0, 0),
					SoundID = nil,
					SoundPitch = nil,
					SoundVolume = nil
				})
				GYRO.cframe = CF(RootPart.Position, TORSO.Position)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-25)), 2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(25)), 2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 22), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(90)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0 + 0.025 * COS(SINE / 22), -1) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(90 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				if ANIM == "Idle" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				elseif ANIM == "Walk" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
				elseif ANIM == "Jump" or ANIM == "Fall" then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
				end
			end
		end
	end
	ATTACK = false
	Rooted = false
end
function Fire_At_Will()
	ATTACK = true
	Rooted = false
	local GYRO = IT("BodyGyro", RootPart)
	GYRO.D = 750
	GYRO.P = 2000
	GYRO.MaxTorque = VT(0, 40000, 0)
	for i = 0, 0.2, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.48, -0.5) * ANGLES(RAD(90), RAD(0), RAD(-12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		if ANIM == "Idle" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		elseif ANIM == "Walk" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ANIM == "Jump" or ANIM == "Fall" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
		end
	end
	local BOMB = CreatePart(3, Effects, "Neon", 0, 0, "Burgundy", "Sphere", VT(1, 1, 1), false)
	MakeForm(BOMB, "Ball")
	BOMB.Mesh.Scale = VT(0.5, 0.5, 0.5)
	local WELD = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, BOMB, CF(0, -2, 0), CF(0, 0, 0))
	for i = 0, 1.5, 0.1 / Animation_Speed do
		Swait()
		if MRANDOM(1, 2) == 1 then
			for E = 1, #EYES do
				if EYES[E] ~= nil then
					local EY = EYES[E]
					local LIGHTNING = Zap({
						StartPosition = EY.Position,
						TargetPosition = BOMB.Position,
						Character = Character,
						Color = "Burgundy",
						Individual = false,
						MaxRange = 7,
						SegmentLength = 1,
						Offset = 0.3,
						SIZE = 0.05
					})
					Debris:AddItem(LIGHTNING.LightningModel, 0.05)
				end
			end
		end
		BOMB.Mesh.Scale = BOMB.Mesh.Scale + VT(0.1, 0.1, 0.1)
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.48, -0.5) * ANGLES(RAD(90), RAD(0), RAD(-12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		if ANIM == "Idle" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		elseif ANIM == "Walk" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ANIM == "Jump" or ANIM == "Fall" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
		end
	end
	WACKYEFFECT({
		Time = 25,
		EffectType = "Ring",
		Size = VT(0, 0, 0),
		Size2 = VT(3.75, 3.75, 0),
		Transparency = 0.7,
		Transparency2 = 1,
		CFrame = RootPart.CFrame * CF(0, -0.25, -1.3),
		MoveToPos = nil,
		RotationX = 0,
		RotationY = 0,
		RotationZ = 0,
		Material = "Neon",
		Color = BOMB.Color,
		SoundID = nil,
		SoundPitch = nil,
		SoundVolume = nil
	})
	WACKYEFFECT({
		Time = 50,
		EffectType = "Ring",
		Size = VT(0, 0, 0),
		Size2 = VT(15, 15, 0),
		Transparency = 0.7,
		Transparency2 = 1,
		CFrame = RootPart.CFrame * CF(0, -0.25, -1.3),
		MoveToPos = nil,
		RotationX = 0,
		RotationY = 0,
		RotationZ = 0,
		Material = "Neon",
		Color = BOMB.Color,
		SoundID = nil,
		SoundPitch = nil,
		SoundVolume = nil
	})
	BOMB.Anchored = true
	WELD:remove()
	GYRO:remove()
	coroutine.resume(coroutine.create(function()
		BOMB.CFrame = CF(BOMB.Position, Mouse.Hit.p)
		for i = 1, 500 do
			Swait()
			BOMB.CFrame = BOMB.CFrame * CF(0, 0, -2)
			local HITFLOOR, HITPOS = Raycast(BOMB.Position, BOMB.CFrame.lookVector, 2.2, Character)
			if HITFLOOR ~= nil then
				break
			end
		end
		ApplyAoE(BOMB.Position, 75, 0, 0, 0, true)
		for i = 1, 3 do
			WACKYEFFECT({
				Time = 35,
				EffectType = "Swirl",
				Size = VT(0, 0, 0),
				Size2 = VT(150, 225, 150) + VT(5, 15, 5) * i,
				Transparency = 0,
				Transparency2 = 1,
				CFrame = BOMB.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 5 * i,
				RotationZ = 0,
				Material = "Neon",
				Color = BOMB.Color,
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		for i = 1, 5 do
			WACKYEFFECT({
				Time = 75,
				EffectType = "Sphere",
				Size = BOMB.Mesh.Scale,
				Size2 = VT(25, 25, 25) * i,
				Transparency = 0.5,
				Transparency2 = 1,
				CFrame = BOMB.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = BOMB.Color,
				SoundID = 1222405264,
				SoundPitch = 1,
				SoundVolume = 10
			})
		end
		local HITFLOOR, HITPOS = Raycast(BOMB.Position, CF(BOMB.Position + VT(0, 1, 0), BOMB.Position - VT(0, 1, 0)).lookVector, 15, Character)
		if HITFLOOR then
			CreateDebreeRing(HITFLOOR, HITPOS, 15, VT(8, 8, 8), 5)
		end
		BOMB.Transparency = 1
		for i = 1, 35 do
			Swait()
			CreateFlyingDebree(BOMB, CF(BOMB.Position), 1, VT(0.5, 0.5, 0.5), 5, 150)
		end
		BOMB:remove()
	end))
	ATTACK = false
	Rooted = false
end
function Imperfect_Storm()
	ATTACK = true
	Rooted = false
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		if ANIM == "Idle" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		elseif ANIM == "Walk" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ANIM == "Jump" or ANIM == "Fall" then
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
		end
	end
	ATTACK = false
	Rooted = false
end
function MouseDown(Mouse)
	if ATTACK == false then
	end
end
function MouseUp(Mouse)
	HOLD = false
end
function KeyDown(Key)
	KEYHOLD = true
	if FINISHEDINTRO == true then
		if Key == "z" and ATTACK == false then
			Neck_Snap()
		end
		if Key == "b" and ATTACK == false then
			Imperfect_Command()
		end
		if Key == "c" and ATTACK == false then
			Fire_At_Will()
		end
		if Key ~= "v" or ATTACK == false then
		end
		if Key ~= "x" or ATTACK == false then
		end
	end
end
function KeyUp(Key)
	KEYHOLD = false
end
Mouse.Button1Down:connect(function(NEWKEY)
	MouseDown(NEWKEY)
end)
Mouse.Button1Up:connect(function(NEWKEY)
	MouseUp(NEWKEY)
end)
Mouse.KeyDown:connect(function(NEWKEY)
	KeyDown(NEWKEY)
end)
Mouse.KeyUp:connect(function(NEWKEY)
	KeyUp(NEWKEY)
end)
function unanchor()
	if UNANCHOR == true then
		RootPart.Anchored = false
	end
	local CHILDREN = Character:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD:IsA("BasePart") and CHILD ~= RootPart and CHILD.Parent ~= Effects and CHILD.Parent.Parent ~= Effects then
			CHILD.Anchored = false
		end
	end
end
Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and Disable_Jump == true then
		Humanoid.Jump = false
	end
end)
while true do
	Swait()
	script.Parent = WEAPONGUI
	ANIMATE.Parent = nil
	if Humanoid then
		local IDLEANIMATION = Humanoid:LoadAnimation(ROBLOXIDLEANIMATION)
		IDLEANIMATION:Play()
	end
	for RW = 1, #RWINGS do
		if RWINGS[RW] ~= nil then
			RWINGS[RW].C1 = Clerp(RWINGS[RW].C1, CF(-0.25 + 0.25 * COS(SINE / 22), 0, 0 + 0.15 * COS(SINE / 22)) * ANGLES(RAD(2.5 * SIN(SINE / 22)), RAD(0), RAD(0 + 5 * SIN(SINE / 22))), 1 / Animation_Speed)
		end
	end
	for LW = 1, #LWINGS do
		if LWINGS[LW] ~= nil then
			LWINGS[LW].C1 = Clerp(LWINGS[LW].C1, CF(0.25 - 0.25 * COS(SINE / 22), 0, 0 + 0.15 * COS(SINE / 22)) * ANGLES(RAD(2.5 * SIN(SINE / 22)), RAD(0), RAD(0 - 5 * SIN(SINE / 22))), 1 / Animation_Speed)
		end
	end
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4 + Humanoid.HipHeight, Character)
	local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	if FINISHEDINTRO == true then
		if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
			ANIM = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			end
		elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
			ANIM = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 22)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 22)), RAD(15), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.025 * COS(SINE / 22), -1) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0 + 0.025 * COS(SINE / 22), -1) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(90 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 22), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 22), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 22)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 22)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 22)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 22))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 22), 0) * ANGLES(RAD(-25), RAD(0 - 2.5 * SIN(SINE / 22)), RAD(15 + 7.5 * SIN(SINE / 22))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 22), 0) * ANGLES(RAD(-25), RAD(0 + 2.5 * SIN(SINE / 22)), RAD(-15 - 7.5 * SIN(SINE / 22))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 22)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 22)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		end
		if TORSOVELOCITY > 1 then
			Humanoid.HipHeight = 1
		else
			Humanoid.HipHeight = 0
		end
	elseif FINISHEDINTRO == false then
		Humanoid.HipHeight = 0
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.Parent = Torso
	sick.Playing = true
	sick.Volume = 3
	sick.Pitch = 1
	BLINKLOOP = BLINKLOOP + 1
	if BLINKLOOP >= 650 then
		BLINKLOOP = 0
		Blink()
	end
	if Character:FindFirstChildOfClass("Accessory") then
		Character:FindFirstChildOfClass("Accessory"):remove()
	end
	if Head:FindFirstChildOfClass("Sound") then
		Head:FindFirstChildOfClass("Sound"):remove()
	end
	if INTROING == false and FINISHEDINTRO == false then
		if INSTANT == false then
			Intro()
		else
			FINISHEDINTRO = true
			Face()
			RightWing()
			LeftWing()
		end
	end
	if Head:FindFirstChild("face") then
		Head.face:remove()
	end
	refit()
	Humanoid.PlatformStand = false
end